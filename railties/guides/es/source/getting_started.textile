h2. Comenzando con Rails

Esta guía cubre la instalación y arranque de Ruby on Rails. Al final de la misma, deberás estar
familiarizado con:

* Instalación y la creación de una nueva aplicación de Rails, ademas de como conectar tu aplicación a una base de datos.
* La estructura general de una aplicación Rails.
* Los principios básicos del patrón MVC (Modelo, Vista, Controlador) y el diseño orientado a recuersos (REST)
* Como generar rapidamente las partes basicas de una aplicación en Rails.

endprologue.

WARNING. Esta guía esta basada en Rails 3.1. Algunos de los códigos aqui mostrados no
podrán funcionar en versiones anteriores de Rails.

h3. Esta guía asume

Esta guía esta diseñada para principiantes que quieren comenzar con una aplicación
de Rails desde el principio. No asume que se tenga una experiencia previa en Rails.
Sin embargo, para entender la mayor parte de la misma, es necesario tener algunos
pre requisitos instalados:

* El lenguaje de programación "Ruby":http://www.ruby-lang.org/en/downloads versión 1.8.7+

TIP: Tenga en cuenta que Ruby 1.8.7 p248 y p249 tiene algunos errores que suspenden la ejecución
de una aplicación Rails 3.0. Aunque Ruby Enterprise Edition ha solucionado estos errores desde el
lanzamiento de la versión 1.8.7-2010.02. Si se tiene la versión 1.9.1 de Ruby y se quiere utilizar
la versión 3.0 de Rails es preferible actualizar a Ruby 1.9.2 dado ciertos problemas de Rails 3.0
con Ruby 1.9.1.

* El sistema de paquetes:http://rubyforge.org/frs/?group_id=126 "RubyGems"
  ** Si deseas aprender más sobre RubyGems, por favor lee el "Manual de Usuario":http://docs.rubygems.org/read/book/1
* Una instalación adecuada de la Base de datos "SQLite3":http://www.sqlite.org

Rails es un framework para el desarrollo de aplicaciones web que se ejecuta sobre el lenguaje de programación Ruby.
Si no tienes experiencia en Ruby, encontrarás esta guia un poco confusa al intentar aprender directamente Rails.
He aquí algunas referencias en internet muy buenas sobre el aprendizaje de Ruby, incluyendo:

* "Mr. Neighborly's Humble Little Ruby Book":http://www.humblelittlerubybook.com
* "Programming Ruby":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Why's (Poignant) Guide to Ruby":http://mislav.uniqpath.com/poignant-guide/

También el código usado para esta guia esta disponible en el repositorio de Github: https://github.com/rails/rails
en rails/railties/guides/code/getting_started.

h3. ¿Qué es Rails?

Rails es framework para el desarrollo de aplicaciones web escrito en el lenguaje Ruby.
Esta diseñado para hacer más facil el desarrollo de las mismas haciendo varios supuestoss sobre
lo que desarrollador necesita para empezar. Rails permite escribir menos códigos y obtener
más resultados que otros lenguajes y frameworks existentes.
Desarrolladores expertos también han reportado que Rails hace del desarrollo de aplicaciones una
experiencia mas divertida.

Rails es un software opinable; es decir que asume que hay un "mejor" método para hacer las
cosas, y esta diseñado para lograrlo de esa manera - y en algunos casos hasta descarta ciertas
alternativas. Si aprendes al "Modo Rails" muy probablemente descubrirás un tremendo incremento
en tu productividad. Si persistes en mantener hábitos viejos de otros lenguajes a tu desarrollo
en Rails, y tratas de usar patrones que has aprendido en otros lados podrías llegar a tener una
experiencia no muy placentera.

La filosofia de Rails incluye varios principios:
* DRY - "No te Repitas (Don't Repeat Yourself)" - sugiere que escribir el mismo código una y otra vez es una mala práctica.
* Convention Over Configuration "Convención sobre Configuración" - significa que Rails asume acerca de lo que quieres hacer
y cómo lo vas a realizar, en vez de requerirte que especifiques cada pequeño detalle atravez de un sin numero de archivos de
configuración.
* REST es el mejor patrón para las aplicaciones web - organizar tu aplicación alrededor de recursos y verbos estándar de HTTP
es la manera más rápida de lograrlo.

h4. La arquitectura MVC

Rails está organizado alrededor de la arquitectura Modelo, Vista, Controlador, generalmente conocida como MVC. Los beneficios 
que incluye la arquitectura MVC son:

* Separación de la lógica de negocios y la interface de usuario
* Facilidad para aplicar el principio DRY
* Deja claro donde pertenece cada parte del código facilitando el mantenimiento

h5. Modelos

Un Modelo representa la información (datos) de la aplicación y las reglas para manipular esos datos. En el caso de Rails, los Modelos 
se usan principalmente para administrar las reglas de interacción con la correspondiente tabla en la base de datos. En la mayoría de 
los casos, una tabla en la base de datos corresponderá con un modelo en la aplicación. La mayor parte de la lógica de negocios de la 
aplicación se concentrará en los Modelos.

h5. Vistas

Las Vistas representan la interface de usuario de tu aplicación. En Rails, las vistas generalmente son archivos HTML con código Ruby 
incrustado que realizan tareas únicamente relacionadas con la presentación de datos. Las Vistas hacen el trabajo de proveer datos al 
navegador web u otra herramienta utilizada para hacer peticiones a tu aplicación.

h5. Controladores

Los Controladores proveen el "pegamento" entre los Modelos y las Vistas. En Rails, los Controladores son responsables de procesar 
las peticiones del navegador web, solicitando datos a los Modelos y pasando esos datos a las Vistas para que los presenten.

h4. Los componentes de Rails

Rails viene con varios componentes individuales. Cada uno de estos componentes son brevemente explicados abajo.
Si eres nuevo en Rails al leer esta sección, no te quedes atorado en los detalles de cada componente, ya que estos serán
explicados con más detalle mas adelante. Por ende, vamos a utilizar aplicaciones Rack, pero no necesitas saber
algo sobre ellas para continuar con esta guía.

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties

h5. Action Pack

El Action Pack es una simple gem que contiene el Action Controller, Action View y el
Action Dispatch. El "VC" del patrón "MVC".

h6. Action Controller

El Action Controller es el componente que maneja los controladores en una aplicación Rails.
Su framework procesa todos las solicitudes entrantes de una aplicación en Rails, extrae parámetros,
y los despacha a su Action correspondiente. Los servicios proveídos por el Action Controller incluyen
el manejo de las sesiones y del redireccionamiento además de la reproducción de plantillas.

h6. Action View

El Action View maneja las vistas de una aplicación Rails. Puede crear por defecto ambas salidas HTML y XML.
Maneja la reproducción de plantillas, incluyendo plantillas anidadas o parciales; viene con un soporte integrado
de AJAX. Las plantillas de las vistas son cubiertas con más detalle en otra guía llamada "Diseños y 
Reproducciones":layouts_and_rendering_es.html

h6. Action Dispatch

El Action Dispatch enruta todas las peticiones web y los envía como tu deseas, ya sea a tu aplicación o algun
otra aplicación Rack. Las aplicaciones Rack son un tópico mas avanzado y que es cubierto en una guía separada
llamada "Rails en Rack":rails_on_rack_es.html

h5. Action Mailer

El Action Mailer es un framework para servicios integrados de correo electrónicos. Puedes usar el Action Mailer
para recibir y procesar correos entrantes y enviar simples textos o correos complejos basado en plantillas flexibles.

h5. Active Model

El Active Model provee una interfaz definida entre los servicios del gem del Action Pak y el gem del mapeo objeto-relacional
llamado Active Record. Un Active Model permite a Rails utilizar otros ORM (Mapeo objeto-relacional) frameworks en lugar del
Active Record si tu aplicación lo necesita.

h5. Active Record

Active Record es la base para los Modelos en una aplicación Rails. Provee de independencia de la base de datos, funcionalidad 
básica de CRUD, capacidades avanzadas de búsqueda y la habilidad de relacionar modelos entre si, entre otros servicios.

h5. Active Resource

Active Resource provee de un framework para administrar la conexión entre objetos de negocios y servicios web basados en REST. 
Implemente un mecanismo para mapear recursos basado en web a objetos locales con comportamientos CRUD.

h5. Active Support

Active Support es una extensa colección de clases auxiliares y extensiones a la biblioteca estándar de Ruby que se utilizan en Rails,
tanto como por el código base como por tus aplicaciones.

h5. Railties

Railties es el código base de Rails que crea nuevas aplicaciones Rails y empalma los diversos frameworks en cualquier aplicación Rails.

h4. REST

Rest significa Representational State Transfer y es la fundación de la arquitectura REST. Es generalmente considerao como la tesis del 
doctorado de Roy Fielding, "Architectural Styles and the Design of Network-based Software
Architectures":http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm. Mientras puedas leer la tesis, Rest para Rails cae dentro
de 2 principios principales:

* Utilizar identificadores de recursos tales como URLs como representantes.
* Representaciones transferibles de estado de un recurso entre los componentes de un sistema.

Por ejemplo, la siguiente petición de HTTP:

<tt>DELETE /photos/17</tt>

sería entendido como referencia a un recurso fotografico con un ID de 17, y para indicar una acción deseada - borrar ese
recurso. REST es un estilo natural para la arquitectura de aplicaciones web y Rails lo hace más natural utilizando convenciones 
que nos aíslan de las complejidades de REST.

Si deseas saber mas detalles acerca de REST como un estilo arquitectonico, estos recursos son más digeribles que la tesis de
Fielding:

* "A Brief Introduction to REST":http://www.infoq.com/articles/rest-introduction by Stefan Tilkov
* "An Introduction to REST":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) by Joe Gregorio
* "Representational State Transfer":http://en.wikipedia.org/wiki/Representational_State_Transfer article in Wikipedia
* "How to GET a Cup of Coffee":http://www.infoq.com/articles/webber-rest-workflow by Jim Webber, Savas Parastatidis &
Ian Robinson

h3. Creando un nuevo proyecto de Rails

Si sigues esta guía, crearás un proyecto de Rails llamado <tt>blog</tt>, un (muy) simple weblog.
Antes de comenzar a construir la aplicación, necesitas estar seguro que tienes Rails instalado.

TIP: Los ejemplos siguientes usa # y $ para denotar prompts de terminales. Si estas usando Windows, tu prompt lucirá como c:\source_code>

h4. Instalando Rails

En muchos casos, la manera más facil de instalar Rails es tomar ventaja de los RubyGems:

<shell>
Usualmente corre lo siguiente como el usuario raiz:
# gem install rails
</shell>

TIP. Si estas trabajando en Windows, puedes rapidamente instalar Ruby y Rails con
"Rails Installer":http://railsinstaller.org.

h4. Creando una Aplicación Blog

La mejor manera de usar esta guía es seguir cada paso como se explica, ningún código o paso
necesitado para realizar el ejemplo fue olvidado, por ende puedes seguir literalmente paso a 
paso. Si necesitas el código completo, lo puedes bajar de "Getting Started
Code":https://github.com/mikel/getting-started-code.

Para empezar, abre una terminal o consola, navega hasta el folder donde tienes los permisos
adecuados para crear archivos y digita:

<shell>
$ rails new blog
</shell>

Esto creará una aplicación Rails llamada Blog en un directorio llamado blog.

TIP: Puedes ver todas las opciones que el constructor de una aplicación Rails acepta, corriendo
<tt>rails new -h</tt>.

Después de crear la aplicación blog, cambia a su folder para continuar trabajando directamente
en la aplicación:

<shell>
$ cd blog
</shell>

En cualquier caso, Rails creará un folder en tu directorio de trabajo llamado <tt>blog</tt>. 
Abre dicho folder y explora sus contenidos. La mayoría del trabajo en este tutorial sucederá
en el folder <tt>app/</tt>, pero he aquí una explicación básica de la función de cada folder
que Rails crea en una nueva aplicación por defecto:

|_.File/Folder|_.Purpose|
|Gemfile|Este archivo permite que tu especifiques que dependencia de gems son necesitadas por tu aplicación Rails. Mira la sección de Bundler, abajo.|
|README| Este es un breve manual de instrucciones para tu aplicación. Tu puedes editar dicho archivo y contar a otros de que es lo que hace tu aplicación, como configurarlo, entre otras cosas.|
|Rakefile|Este archivo localiza y carga las tareas que pueden ser ejecutadas en la consola o terminal. La definición de tareas son explicadas a través de los componentes de Rails. En vez de cambiar el Rakefile, tu deberías agregar tus propias tareas dentro del folder lib/tasks de tu aplicación.|
|app/|Contiene los controladores, modelos, vistas y recursos para tu aplicación. Te concentrarás en este folder durante esta guía.|
|config/|Configura las reglas de ejecución, rutas, base de datos entre otras cosas de tu aplicación.|
|config.ru|Congiguración Rack para servidores basados en Rack usados para comenzar tu aplicación.|
|db/|Muestra el esquema actual de tu base de datos, asi como las migraciones. Aprenderás acerca de migraciones en breve.|
|doc/|Documentación mas profunda acerca de tu aplicación.|
|lib/|Módulos extendidos para tu aplicación (no abarcados en esta guía).|
|log/|Los archivos log de la aplicación.|
|public/|El único folder visto por el mundo como tal. Contiene archivos estáticos y recursos compilados.|
|script/|Contiene los scripts de Rails que hacen comenzar tu aplicación y puede contener otros scripts que puedes usar para publicar o ejecutar tu aplicación.|
|test/|Pruebas unitarias, fixtures en otros componentes de prueba. Estos son cubiertos por el tutorial "Test Aplicaciones Rails":testing.html|
|tmp/|Archivos temporales|
|vendor/|Un lugar para códigos de tercero. En una aplicación Rails típica, esto incluye Ruby Gems, el código fuente de Rails (si lo instalas dentro del proyecto) y plugins que contienen funcionabilidades adicionales.|

h4. Configurando una Base de Datos

Se podría decir que cada aplicación Rails interactúa con una base de datos. La base de datos a usar
es especificada en el archivo de configuración, +config/database.yml+. Si tu abres dicho archivo en 
una nueva aplicación Rails, encontrarás una configuración de base de datos por defecto usando SQLite3.
Este archivo contiene secciones para 3 diferentes ambientes en los cuales Rails puede ejecutarse por defecto:

* El ambiente +development+ (desarrollo) es usado en tu computadora para que interactúes manualmente con la aplicación.
* El ambiente +test+ (prueba) es usado para correr pruebas automatizadas.
* El ambiente +production+ (producción) es usado cuando tu publicas tu aplicación al mundo para que la use.

h5. Configurando una Base de Datos de SQLite3

Rails viene con un soporte integrado para "SQLite3":http://www.sqlite.org, la cual es una
aplicación de base de datos ligera y sin necesidad de un server. Mientras que un ambiente congestionado
de producción puede sobrecargar SQLite, esta trabaja de muy bien para ambientes de desarrollo y pruebas.
Rails usa por defecto una base de datos SQLite pero tu puedes cambiarla después.

He aquí una sección del archivo de configuración por defecto:
(<tt>config/database.yml</tt>) con la información de conexión necesaria para el ambiente de desarrollo:

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: En esta guía se usa una base de datos SQLite3 para el almacenamiento, porque es una configuración
básica de base de datos que trabaja muy bien. Rails también soporta MySQL y PostgreSQL, además tiene 
plugins para otros sistemas de base de datos. Si usas una base de datos en un ambiente de producción
muy seguro haya un adaptador para tal.

h5. Configurando una base de datos de MySQL

Si tu deseas usar MySQL en vez de SQLite3, tu +config/database.yml+ se verá un poco diferente. He aquí
la sección del ambiente de desarrollo:

<yaml>
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

Si tu computadoras para desarrollo tiene una instalación de MySQL que incluye un usuario raíz
con un password vacío, esta configuración debería de trabajar perfectamente. Si no, cambia el
usuario y password apropiados en la sección de +development+.

h5. Configurando una base de datos de PostgreSQL

Si eliges PostgreSQL, tu +config/database.yml+ deberá ser editado para que use bases de datos
PostgreSQL:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

h5. Configurando una base de datos SQLite3 para una plataforma JRuby

Si decides usar SQLite3 y estas usando JRuby, tu +config/database.yml+ se verá un poco
diferente. He aquí la sección de desarrollo:

<yaml>
development:
  adapter: jdbcsqlite3
  database: db/development.sqlite3
</yaml>

h5. Configurando una base de datos  MySQL para una plataforma JRuby

Si decides usar MySQL y estas usando JRuby, tu +config/database.yml+ se verá un poco
diferente. He aquí la sección de desarrollo:

<yaml>
development:
  adapter: jdbcmysql
  database: blog_development
  username: root
  password:
</yaml>

h5. Configurando una base de datos  PostgreSQL para una plataforma JRuby

Finalmente si decides usar PostgreSQL y JRuby, tu +config/database.yml+ se verá un poco
diferente. He aquí la sección de desarrollo:

<yaml>
development:
  adapter: jdbcpostgresql
  encoding: unicode
  database: blog_development
  username: blog
  password:
</yaml>

Recuerda cambiar el usuario y password apropiados en la sección de +development+

TIP: No tienes que actualizar las configuraciones de las bases de datos manualmente. Si miras en
las opciones del generado de aplicaciones, verás que una de las opciones es llamada <tt>--database</tt>.
Esta opción te permite seleccionar un adaptador de una lista de las más usadas bases de datos relacionales.
También puedes incluso ejecutar el generador repetidamente: <tt>cd .. && rails new blog --database=mysql</tt>.
Cuando confirmes la sobre escritura del archivo +config/database.yml+, tu aplicación será configurada
para MySQL en vez de SQLite.

h4. Creando una base de datos

Ahora que tienes la base de datos configurada, es tiempo para que Rails cree una base de datos vacía para ti.
Puedes hacerlo al ejecutar el comando rake:

<shell>
$ rake db:create
</shell>

Esto creará la bases de datos SQLite3 para los ambientes de desarrollo y pruebas dentro del folder
<tt>db/</tt>.

TIP: Rake ejecuta comandos de propósitos generales y Rails lo utiliza para muchas cosas.
Puedes ver la lista de comandos rake disponibles en tu aplicación al correr:
+rake -T+.

h3. Hola, Rails!

Uno de los puntos mas tradicionales para comenzar a aprender un nuevo lenguaje es mostrar un
simple texto en pantalla rápidamente. Para hacerlo, necesitas poner en ejecución el servidor
de tu aplicación Rails

h4. Arrancando el Servidor Web

Actualmente tienes una aplicación Rails funcional. Para comprobarlo necesitas arrancar el
servidor web de tu computadora de desarrollo. Lo puedes lograr ejecutando:

<shell>
$ rails server
</shell>

Esto arrancará una instancia del servidor web por defecto WEBrick (Rails puede usar un gran numero
de otros servidores web). Para comprobar que la aplicación se esta ejecutando con éxito, abre un
navegador y ve hacia "http://localhost:3000":http://localhost:3000.
Deberías ver la página informativa por defecto de Rails:
!images/rails_welcome.png(Welcome Aboard screenshot)!

TIP: Para detener el servidor web, teclea Ctrl+C en ventana de la terminal donde el servidor
esta ejecutándose. En el modo de desarrollo, Rails por lo general no requiere que pares el 
servidor cuando haces cambios a los archivos; estos serán actualizados automáticamente.

La página "Welcome Aboard" es la _prueba de humo_ para una aplicación en Rails: en la misma
se valida que tu tengas el software configurado correctamente para mostrar una página.
También puedes darle click en el link _About your application’s environment_ (Acerca del ambiente 
de tu aplicación) para ver un detalle sumarizado del ambiente de ejecución.

h4. Di "Hola", Rails

Para lograr que Rails diga "Hola",necesitarás como minimo crear un controlador y una vista.
Afortunadamente, lo puedes lograr en una sola linea de comandos. Ejecuta este comando en tu
terminal:

<shell>
$ rails generate controller home index
</shell>

TIP: Si recibes un error al ejecutar el comando, necesitas pasar explicitamente comandos de
Rails +rails+ a Ruby: <tt>ruby\path\to\your\application\script\rails generate controller home index</tt>.

Rails creará varios archivos para ti, incluyendo
+app/views/home/index.html.erb+. Esta plantilla será usada para desplegar
los resultados de la acción (método) +index+ en el controlador +home+.
Abre este archivo en un editor de texto y edítalo para contener una sola línea de código:

<code class="html">
<h1>Hola, Rails!</h1>
</code>

h4. Configurando la página de Inicio de la Aplicación

Ahora que hemos creado el controlador y la vista, necesitamos decirle a Rails que
queremos mostrar "Hola, Rails". En nuestro caso, queremos que se muestre cuando se
navega al URL raiz de nuestro sitio, "http://localhost:3000":http://localhost:3000, 
en vez de la prueba de humo "Welcome Aboard".

El primer paso para lograr esto es borrando la página por defecto de tu aplicación:

<shell>
$ rm public/index.html
</shell>

Necesitamos hacer esto para que Rails pueda entregar cualquier archivo estático en el
directorio +public+ en preferencia a cualquier contenido dinámico que generamos desde
los controladores.

Ahora, tienes que decirle a Rails donde esta localizada tu página de inicio. Abre el 
archivo +config/routes.rb+ en tu editor. Este es el _archivo de enrutamiento_ de tu
aplicación el cual contiene todas las entradas en un especial DSL (lenguaje de dominios
específicos) que le dice a Rails como conectar peticiones entrantes con controladores y
acciones. Este archivo contiene varias rutas de ejemplo en líneas de comentarios, y una
de ellas actualmente muestra como conectar la raíz de tu sitio con un controlador  y una
acción específica. Encuentra dicha linea comenzando con +root :to+, des coméntalo y cámbialo
como lo siguiente:

<ruby>
Blog::Application.routes.draw do

  #...
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to => "home#index"
</ruby>

La instrucción +root :to => "home#index"+ le dice a Rails que mapee la acción raíz con el
controlador de la acción índice.

Ahora si navegas a "http://localhost:3000":http://localhost:3000 en tu navegador, verás que
dice +Hola, Rails!+.

NOTE. Para más información acerca de enrutamiento, ve a la página "Rails enrutando desde
afuera hacia adentro":routing.html.

h3. Comenzando y Corriendo rápidamente con Scaffolding

Rails _scaffolding_ es una forma rápida de generar algunos de las mayores piezas de una
aplicación. Si deseas crear los modelos, vistas, y controladores para un nuevo recurso
en una sola operación, scaffolding es la herramienta que necesitas.

h3. Creando un Recurso

En el caso de la aplicación blog, tu puedes comenzar generando un recurso Post (entradas del Blog) con el
scaffold: esto representará un solo post del blog. Para hacer esto, corre lo siguiente
en la terminal:

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

El generador scaffold construirá una colección de archivos en tu aplicación, en conjunto con
algunos directorios, y editará <tt>config/routes.rb</tt>. He aquí un resumen de lo que se crea:

|_.Archivo                                    |_.Propósito|
|db/migrate/20100207214725_create_posts.rb    |Migración para crear la tabla de posts en la base de datos (tu numbre incluirá una fecha y hora diferente)|
|app/models/post.rb                           |El modelo Post|
|test/fixtures/posts.yml                      |posts sin sentido para ser usados en pruebas|
|app/controllers/posts_controller.rb          |El controlador de los Posts|
|app/views/posts/index.html.erb               |Una vista para desplegar un indice de todos los posts|
|app/views/posts/edit.html.erb                |Una vista para editar un post existente|
|app/views/posts/show.html.erb                |Una vista para desplegar un post existente|
|app/views/posts/new.html.erb                 |Una vista para crear un nuevo post|
|app/views/posts/_form.html.erb               |Un página parcial para tener el control del diseño en las formas dentro de las vistas de edición y nuevos|
|app/helpers/posts_helper.rb                  |Funciones de ayuda para ser usadas dentro de las vistas de los posts|
|app/assets/stylesheets/scaffolds.css.scss    |Hoja de estilo en cascada (css) para hacer que el scaffold luzca mejor|
|app/assets/stylesheets/posts.css.scss        |Css para el controlador de los posts|
|app/assets/javascripts/posts.js.coffee       |Archivo CoffeeScript para el controlador de los posts|
|test/unit/post_test.rb                       |Pruebas Unit para el modelo Post|
|test/functional/posts_controller_test.rb     |Pruebas funcionales para el controlador de posts|
|test/unit/helpers/posts_helper_test.rb       |Pruebas Unit para las funciones de ayuda de los posts|
|config/routes.rb                             |Modificado para incluir información sobre los posts|

NOTE. While scaffolding will get you up and running quickly, the code it
generates is unlikely to be a perfect fit for your application. You'll most
probably want to customize the generated code. Many experienced Rails developers
avoid scaffolding entirely, preferring to write all or most of their source code
from scratch. Rails, however, makes it really simple to customize templates for
generated models, controllers, views and other source files. You'll find more
information in the "Creating and Customizing Rails Generators &
Templates":generators.html guide.

h4. Running a Migration

One of the products of the +rails generate scaffold+ command is a _database
migration_. Migrations are Ruby classes that are designed to make it simple to
create and modify database tables. Rails uses rake commands to run migrations,
and it's possible to undo a migration after it's been applied to your database.
Migration filenames include a timestamp to ensure that they're processed in the
order that they were created.

If you look in the +db/migrate/20100207214725_create_posts.rb+ file (remember,
yours will have a slightly different name), here's what you'll find:

<ruby>
class CreatePosts < ActiveRecord::Migration
  def change
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end
end
</ruby>

The above migration creates a method named +change+ which will be called when you
run this migration. The action defined in that method is also reversible, which
means Rails knows how to reverse the change made by this migration, in case you
want to reverse it at later date. By default, when you run this migration it
creates a +posts+ table with two string columns and a text column. It also
creates two timestamp fields to track record creation and updating. More
information about Rails migrations can be found in the "Rails Database
Migrations":migrations.html guide.

At this point, you can use a rake command to run the migration:

<shell>
$ rake db:migrate
</shell>

Rails will execute this migration command and tell you it created the Posts
table.

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOTE. Because by default you're working in the development environment, this
command will apply to the database defined in the +development+ section of your
+config/database.yml+ file. If you would like to execute migrations in another
environment, for instance in production, you must explicitly pass it when
invoking the command: <tt>rake db:migrate RAILS_ENV=production</tt>.

h4. Adding a Link

To hook the posts up to the home page you've already created, you can add a link
to the home page. Open +app/views/home/index.html.erb+ and modify it as follows:

<ruby>
<h1>Hello, Rails!</h1>
<%= link_to "My Blog", posts_path %>
</ruby>

The +link_to+ method is one of Rails' built-in view helpers. It creates a
hyperlink based on text to display and where to go - in this case, to the path
for posts.

h4. Working with Posts in the Browser

Now you're ready to start working with posts. To do that, navigate to
"http://localhost:3000":http://localhost:3000/ and then click the "My Blog"
link:

!images/posts_index.png(Posts Index screenshot)!

This is the result of Rails rendering the +index+ view of your posts. There
aren't currently any posts in the database, but if you click the +New Post+ link
you can create one. After that, you'll find that you can edit posts, look at
their details, or destroy them. All of the logic and HTML to handle this was
built by the single +rails generate scaffold+ command.

TIP: In development mode (which is what you're working in by default), Rails
reloads your application with every browser request, so there's no need to stop
and restart the web server.

Congratulations, you're riding the rails! Now it's time to see how it all works.

h4. The Model

The model file, +app/models/post.rb+ is about as simple as it can get:

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

There isn't much to this file - but note that the +Post+ class inherits from
+ActiveRecord::Base+. Active Record supplies a great deal of functionality to
your Rails models for free, including basic database CRUD (Create, Read, Update,
Destroy) operations, data validation, as well as sophisticated search support
and the ability to relate multiple models to one another.

h4. Adding Some Validation

Rails includes methods to help you validate the data that you send to models.
Open the +app/models/post.rb+ file and edit it:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

These changes will ensure that all posts have a name and a title, and that the
title is at least five characters long. Rails can validate a variety of
conditions in a model, including the presence or uniqueness of columns, their
format, and the existence of associated objects.

h4. Using the Console

To see your validations in action, you can use the console. The console is a
command-line tool that lets you execute Ruby code in the context of your
application:

<shell>
$ rails console
</shell>

TIP: The default console will make changes to your database. You can instead
open a console that will roll back any changes you make by using <tt>rails console
--sandbox</tt> .

After the console loads, you can use it to work with your application's models:

<shell>
>> p = Post.new(:content => "A new post")
=> #<Post id: nil, name: nil, title: nil,
     content: "A new post", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank",
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

This code shows creating a new +Post+ instance, attempting to save it and
getting +false+ for a return value (indicating that the save failed), and
inspecting the +errors+ of the post.

When you're finished, type +exit+ and hit +return+ to exit the console.

TIP: Unlike the development web server, the console does not automatically load
your code afresh for each line. If you make changes to your models while the
console is open, type +reload!+ at the console prompt to load them.

h4. Listing All Posts

The easiest place to start looking at functionality is with the code that lists
all posts. Open the file +app/controllers/posts_controller.rb+ and look at the
+index+ action:

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html  # index.html.erb
    format.json  { render :json => @posts }
  end
end
</ruby>

+Post.all+ calls the +Post+ model to return all of the posts currently in the
database. The result of this call is an array of posts that we store in an
instance variable called +@posts+.

TIP: For more information on finding records with Active Record, see "Active
Record Query Interface":active_record_querying.html.

The +respond_to+ block handles both HTML and JSON calls to this action. If you
browse to "http://localhost:3000/posts.json":http://localhost:3000/posts.json,
you'll see a JSON containing all of the posts. The HTML format looks for a view
in +app/views/posts/+ with a name that corresponds to the action name. Rails
makes all of the instance variables from the action available to the view.
Here's +app/views/posts/index.html.erb+:

<erb>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?',
                                     :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</erb>

This view iterates over the contents of the +@posts+ array to display content
and links. A few things to note in the view:

* +link_to+ builds a hyperlink to a particular destination
* +edit_post_path+ and +new_post_path+ are helpers that Rails provides as part of RESTful routing. You'll see a variety of these helpers for the different actions that the controller includes.

NOTE. In previous versions of Rails, you had to use +&lt;%=h post.name %&gt;+ so
that any HTML would be escaped before being inserted into the page. In Rails
3.0, this is now the default. To get unescaped HTML, you now use +&lt;%= raw
post.name %&gt;+.

TIP: For more details on the rendering process, see "Layouts and Rendering in
Rails":layouts_and_rendering.html.

h4. Customizing the Layout

The view is only part of the story of how HTML is displayed in your web browser.
Rails also has the concept of +layouts+, which are containers for views. When
Rails renders a view to the browser, it does so by putting the view's HTML into
a layout's HTML. In previous versions of Rails, the +rails generate scaffold+
command would automatically create a controller specific layout, like
+app/views/layouts/posts.html.erb+, for the posts controller. However this has
been changed in Rails 3.0. An application specific +layout+ is used for all the
controllers and can be found in +app/views/layouts/application.html.erb+. Open
this layout in your editor and modify the +body+ tag:

<erb>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag "application" %>
  <%= javascript_include_tag "application" %>
  <%= csrf_meta_tags %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</erb>

Now when you refresh the +/posts+ page, you'll see a gray background to the
page. This same gray background will be used throughout all the views for posts.

h4. Creating New Posts

Creating a new post involves two actions. The first is the +new+ action, which
instantiates an empty +Post+ object:

<ruby>
def new
  @post = Post.new

  respond_to do |format|
    format.html  # new.html.erb
    format.json  { render :json => @post }
  end
end
</ruby>

The +new.html.erb+ view displays this empty Post to the user:

<erb>
<h1>New post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
</erb>

The +&lt;%= render 'form' %&gt;+ line is our first introduction to _partials_ in
Rails. A partial is a snippet of HTML and Ruby code that can be reused in
multiple locations. In this case, the form used to make a new post is basically
identical to the form used to edit a post, both having text fields for the name and
title, a text area for the content, and a button to create the new post or to update
the existing one.

If you take a look at +views/posts/_form.html.erb+ file, you will see the
following:

<erb>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited
	    this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

This partial receives all the instance variables defined in the calling view
file. In this case, the controller assigned the new +Post+ object to +@post+,
which will thus be available in both the view and the partial as +@post+.

For more information on partials, refer to the "Layouts and Rendering in
Rails":layouts_and_rendering.html#using-partials guide.

The +form_for+ block is used to create an HTML form. Within this block, you have
access to methods to build various controls on the form. For example,
+f.text_field :name+ tells Rails to create a text input on the form and to hook
it up to the +name+ attribute of the instance being displayed. You can only use
these methods with attributes of the model that the form is based on (in this
case +name+, +title+, and +content+). Rails uses +form_for+ in preference to
having you write raw HTML because the code is more succinct, and because it
explicitly ties the form to a particular model instance.

The +form_for+ block is also smart enough to work out if you are doing a _New
Post_ or an _Edit Post_ action, and will set the form +action+ tags and submit
button names appropriately in the HTML output.

TIP: If you need to create an HTML form that displays arbitrary fields, not tied
to a model, you should use the +form_tag+ method, which provides shortcuts for
building forms that are not necessarily tied to a model instance.

When the user clicks the +Create Post+ button on this form, the browser will
send information back to the +create+ action of the controller (Rails knows to
call the +create+ action because the form is sent with an HTTP POST request;
that's one of the conventions that were mentioned earlier):

<ruby>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html  { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.json  { render :json => @post,
                    :status => :created, :location => @post }
    else
      format.html  { render :action => "new" }
      format.json  { render :json => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

The +create+ action instantiates a new Post object from the data supplied by the
user on the form, which Rails makes available in the +params+ hash. After
successfully saving the new post, +create+ returns the appropriate format that
the user has requested (HTML in our case). It then redirects the user to the
resulting post +show+ action and sets a notice to the user that the Post was
successfully created.

If the post was not successfully saved, due to a validation error, then the
controller returns the user back to the +new+ action with any error messages so
that the user has the chance to fix the error and try again.

The "Post was successfully created." message is stored in the Rails
+flash+ hash (usually just called _the flash_), so that messages can be carried
over to another action, providing the user with useful information on the status
of their request. In the case of +create+, the user never actually sees any page
rendered during the post creation process, because it immediately redirects to
the new +Post+ as soon as Rails saves the record. The Flash carries over a message to
the next action, so that when the user is redirected back to the +show+ action,
they are presented with a message saying "Post was successfully created."

h4. Showing an Individual Post

When you click the +show+ link for a post on the index page, it will bring you
to a URL like +http://localhost:3000/posts/1+. Rails interprets this as a call
to the +show+ action for the resource, and passes in +1+ as the +:id+ parameter.
Here's the +show+ action:

<ruby>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html  # show.html.erb
    format.json  { render :json => @post }
  end
end
</ruby>

The +show+ action uses +Post.find+ to search for a single record in the database
by its id value. After finding the record, Rails displays it by using
+show.html.erb+:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</erb>

h4. Editing Posts

Like creating a new post, editing a post is a two-part process. The first step
is a request to +edit_post_path(@post)+ with a particular post. This calls the
+edit+ action in the controller:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

After finding the requested post, Rails uses the +edit.html.erb+ view to display
it:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
</erb>

Again, as with the +new+ action, the +edit+ action is using the +form+ partial.
This time, however, the form will do a PUT action to the +PostsController+ and the
submit button will display "Update Post".

Submitting the form created by this view will invoke the +update+ action within
the controller:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html  { redirect_to(@post,
                    :notice => 'Post was successfully updated.') }
      format.json  { render :json => {}, :status => :ok }
    else
      format.html  { render :action => "edit" }
      format.json  { render :json => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

In the +update+ action, Rails first uses the +:id+ parameter passed back from
the edit view to locate the database record that's being edited. The
+update_attributes+ call then takes the +post+ parameter (a hash) from the request
and applies it to this record. If all goes well, the user is redirected to the
post's +show+ action. If there are any problems, it's back to the +edit+ action to
correct them.

h4. Destroying a Post

Finally, clicking one of the +destroy+ links sends the associated id to the
+destroy+ action:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to posts_url }
    format.json { head :ok }
  end
end
</ruby>

The +destroy+ method of an Active Record model instance removes the
corresponding record from the database. After that's done, there isn't any
record to display, so Rails redirects the user's browser to the index action of
the controller.

h3. Adding a Second Model

Now that you've seen how a model built with scaffolding looks like, it's time to
add a second model to the application. The second model will handle comments on
blog posts.

h4. Generating a Model

Models in Rails use a singular name, and their corresponding database tables use
a plural name. For the model to hold comments, the convention is to use the name
+Comment+. Even if you don't want to use the entire apparatus set up by
scaffolding, most Rails developers still use generators to make things like
models and controllers. To create the new model, run this command in your
terminal:

<shell>
$ rails generate model Comment commenter:string body:text \
> post:references
</shell>

This command will generate four files:

* +app/models/comment.rb+ - The model.
* +db/migrate/20100207235629_create_comments.rb+ - The migration.
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - The test harness.

First, take a look at +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

This is very similar to the +post.rb+ model that you saw earlier. The difference
is the line +belongs_to :post+, which sets up an Active Record _association_.
You'll learn a little about associations in the next section of this guide.

In addition to the model, Rails has also made a migration to create the
corresponding database table:

<ruby>
class CreateComments < ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end

    add_index :comments, :post_id
  end
end
</ruby>

The +t.references+ line sets up a foreign key column for the association between
the two models. And the +add_index+ line sets up an index for this association
column. Go ahead and run the migration:

<shell>
$ rake db:migrate
</shell>

Rails is smart enough to only execute the migrations that have not already been
run against the current database, so in this case you will just see:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. Associating Models

Active Record associations let you easily declare the relationship between two
models. In the case of comments and posts, you could write out the relationships
this way:

* Each comment belongs to one post.
* One post can have many comments.

In fact, this is very close to the syntax that Rails uses to declare this
association. You've already seen the line of code inside the Comment model that
makes each comment belong to a Post:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

You'll need to edit the +post.rb+ file to add the other side of the association:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

These two declarations enable a good bit of automatic behavior. For example, if
you have an instance variable +@post+ containing a post, you can retrieve all
the comments belonging to that post as an array using +@post.comments+.

TIP: For more information on Active Record associations, see the "Active Record
Associations":association_basics.html guide.

h4. Adding a Route for Comments

As with the +home+ controller, we will need to add a route so that Rails knows
where we would like to navigate to see +comments+. Open up the
+config/routes.rb+ file again. Near the top, you will see the entry for +posts+
that was added automatically by the scaffold generator: <tt>resources
:posts</tt>. Edit it as follows:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

This creates +comments+ as a _nested resource_ within +posts+. This is another
part of capturing the hierarchical relationship that exists between posts and
comments.

TIP: For more information on routing, see the "Rails Routing from the Outside
In":routing.html guide.

h4. Generating a Controller

With the model in hand, you can turn your attention to creating a matching
controller. Again, there's a generator for this:

<shell>
$ rails generate controller Comments
</shell>

This creates six files and one empty directory:

* +app/controllers/comments_controller.rb+ - The controller.
* +app/helpers/comments_helper.rb+ - A view helper file.
* +test/functional/comments_controller_test.rb+ - The functional tests for the controller.
* +test/unit/helpers/comments_helper_test.rb+ - The unit tests for the helper.
* +app/views/comments/+ - Views of the controller are stored here.
* +app/assets/stylesheets/comment.css.scss+ - Cascading style sheet for the controller.
* +app/assets/javascripts/comment.js.coffee+ - CoffeeScript for the controller.

Like with any blog, our readers will create their comments directly after
reading the post, and once they have added their comment, will be sent back to
the post show page to see their comment now listed. Due to this, our
+CommentsController+ is there to provide a method to create comments and delete
spam comments when they arrive.

So first, we'll wire up the Post show template
(+/app/views/posts/show.html.erb+) to let us make a new comment:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This adds a form on the +Post+ show page that creates a new comment by
calling the +CommentsController+ +create+ action. Let's wire that up:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

You'll see a bit more complexity here than you did in the controller for posts.
That's a side-effect of the nesting that you've set up. Each request for a
comment has to keep track of the post to which the comment is attached, thus the
initial call to the +find+ method of the +Post+ model to get the post in question.

In addition, the code takes advantage of some of the methods available for an
association. We use the +create+ method on +@post.comments+ to create and save
the comment. This will automatically link the comment so that it belongs to that
particular post.

Once we have made the new comment, we send the user back to the original post
using the +post_path(@post)+ helper. As we have already seen, this calls the
+show+ action of the +PostsController+ which in turn renders the +show.html.erb+
template. This is where we want the comment to show, so let's add that to the
+app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Commenter:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Comment:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Now you can add posts and comments to your blog and have them show up in the
right places.

h3. Refactoring

Now that we have posts and comments working, take a look at the
+app/views/posts/show.html.erb+ template. It is getting long and awkward. We can
use partials to clean it up.

h4. Rendering Partial Collections

First we will make a comment partial to extract showing all the comments for the
post. Create the file +app/views/comments/_comment.html.erb+ and put the
following into it:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

Then you can change +app/views/posts/show.html.erb+ to look like the
following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This will now render the partial in +app/views/comments/_comment.html.erb+ once
for each comment that is in the +@post.comments+ collection. As the +render+
method iterates over the <tt>@post.comments</tt> collection, it assigns each
comment to a local variable named the same as the partial, in this case
+comment+ which is then available in the partial for us to show.

h4. Rendering a Partial Form

Let us also move that new comment section out to its own partial. Again, you
create a file +app/views/comments/_form.html.erb+ containing:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Then you make the +app/views/posts/show.html.erb+ look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

The second render just defines the partial template we want to render,
<tt>comments/form</tt>. Rails is smart enough to spot the forward slash in that
string and realize that you want to render the <tt>_form.html.erb</tt> file in
the <tt>app/views/comments</tt> directory.

The +@post+ object is available to any partials rendered in the view because we
defined it as an instance variable.

h3. Deleting Comments

Another important feature of a blog is being able to delete SPAM comments. To do
this, we need to implement a link of some sort in the view and a +DELETE+ action
in the +CommentsController+.

So first, let's add the delete link in the
+app/views/comments/_comment.html.erb+ partial:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

Clicking this new "Destroy Comment" link will fire off a <tt>DELETE
/posts/:id/comments/:id</tt> to our +CommentsController+, which can then use
this to find the comment we want to delete, so let's add a destroy action to our
controller:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

The +destroy+ action will find the post we are looking at, locate the comment
within the <tt>@post.comments</tt> collection, and then remove it from the
database and send us back to the show action for the post.


h4. Deleting Associated Objects

If you delete a post then its associated comments will also need to be deleted.
Otherwise they would simply occupy space in the database. Rails allows you to
use the +dependent+ option of an association to achieve this. Modify the Post
model, +app/models/post.rb+, as follows:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. Security

If you were to publish your blog online, anybody would be able to add, edit and
delete posts or delete comments.

Rails provides a very simple HTTP authentication system that will work nicely in
this situation.

In the +PostsController+ we need to have a way to block access to the various
actions if the person is not authenticated, here we can use the Rails
<tt>http_basic_authenticate_with</tt> method, allowing access to the requested
action if that method allows it.

To use the authentication system, we specify it at the top of our
+PostsController+, in this case, we want the user to be authenticated on every
action, except for +index+ and +show+, so we write that:

<ruby>
class PostsController < ApplicationController

  http_basic_authenticate_with :name => "dhh", :password => "secret", :except => [:index, :show]

  # GET /posts
  # GET /posts.json
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

We also only want to allow authenticated users to delete comments, so in the
+CommentsController+ we write:

<ruby>
class CommentsController < ApplicationController

  http_basic_authenticate_with :name => "dhh", :password => "secret", :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# snipped for brevity
</ruby>

Now if you try to create a new post, you will be greeted with a basic HTTP
Authentication challenge

!images/challenge.png(Basic HTTP Authentication Challenge)!

h3. Building a Multi-Model Form

Another feature of your average blog is the ability to tag posts. To implement
this feature your application needs to interact with more than one model on a
single form. Rails offers support for nested forms.

To demonstrate this, we will add support for giving each post multiple tags,
right in the form where you create the post. First, create a new model to hold
the tags:

<shell>
$ rails generate model tag name:string post:references
</shell>

Again, run the migration to create the database table:

<shell>
$ rake db:migrate
</shell>

Next, edit the +post.rb+ file to create the other side of the association, and
to tell Rails (via the +accepts_nested_attributes_for+ macro) that you intend to
edit tags via posts:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

The +:allow_destroy+ option on the nested attribute declaration tells Rails to
display a "remove" checkbox on the view that you'll build shortly. The
+:reject_if+ option prevents saving new tags that do not have any attributes
filled in.

We will modify +views/posts/_form.html.erb+ to render a partial to make a tag:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

Note that we have changed the +f+ in +form_for(@post) do |f|+ to +post_form+ to
make it easier to understand what is going on.

This example shows another option of the render helper, being able to pass in
local variables, in this case, we want the local variable +form+ in the partial
to refer to the +post_form+ object.

We also add a <tt>@post.tags.build</tt> at the top of this form. This is to make
sure there is a new tag ready to have its name filled in by the user. If you do
not build the new tag, then the form will not appear as there is no new Tag
object ready to create.

Now create the folder <tt>app/views/tags</tt> and make a file in there called
<tt>_form.html.erb</tt> which contains the form for the tag:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Tag:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Remove:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

Finally, we will edit the <tt>app/views/posts/show.html.erb</tt> template to
show our tags.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

With these changes in place, you'll find that you can edit a post and its tags
directly on the same view.

However, that method call <tt>@post.tags.map { |t| t.name }.join(", ")</tt> is
awkward, we could handle this by making a helper method.

h3. View Helpers

View Helpers live in <tt>app/helpers</tt> and provide small snippets of reusable
code for views. In our case, we want a method that strings a bunch of objects
together using their name attribute and joining them with a comma. As this is
for the Post show template, we put it in the PostsHelper.

Open up <tt>app/helpers/posts_helper.rb</tt> and add the following:

<erb>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ")
  end
end
</erb>

Now you can edit the view in <tt>app/views/posts/show.html.erb</tt> to look like
this:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= join_tags(@post) %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

h3. What's Next?

Now that you've seen your first Rails application, you should feel free to
update it and experiment on your own. But you don't have to do everything
without help. As you need assistance getting up and running with Rails, feel
free to consult these support resources:

* The "Ruby on Rails guides":index.html
* The "Ruby on Rails Tutorial":http://railstutorial.org/book
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails channel on irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

Rails also comes with built-in help that you can generate using the rake command-line utility:

* Running +rake doc:guides+ will put a full copy of the Rails Guides in the +doc/guides+ folder of your application. Open +doc/guides/index.html+ in your web browser to explore the Guides.
* Running +rake doc:rails+ will put a full copy of the API documentation for Rails in the +doc/api+ folder of your application. Open +doc/api/index.html+ in your web browser to explore the API documentation.

h3. Configuration Gotchas

The easiest way to work with Rails is to store all external data as UTF-8. If
you don't, Ruby libraries and Rails will often be able to convert your native
data into UTF-8, but this doesn't always work reliably, so you're better off
ensuring that all external data is UTF-8.

If you have made a mistake in this area, the most common symptom is a black
diamond with a question mark inside appearing in the browser. Another common
symptom is characters like "Ã¼" appearing instead of "ü". Rails takes a number
of internal steps to mitigate common causes of these problems that can be
automatically detected and corrected. However, if you have external data that is
not stored as UTF-8, it can occasionally result in these kinds of issues that
cannot be automatically detected by Rails and corrected.

Two very common sources of data that are not UTF-8:
* Your text editor: Most text editors (such as Textmate), default to saving files as
  UTF-8. If your text editor does not, this can result in special characters that you
  enter in your templates (such as é) to appear as a diamond with a question mark inside
  in the browser. This also applies to your I18N translation files.
  Most editors that do not already default to UTF-8 (such as some versions of
  Dreamweaver) offer a way to change the default to UTF-8. Do so.
* Your database. Rails defaults to converting data from your database into UTF-8 at
  the boundary. However, if your database is not using UTF-8 internally, it may not
  be able to store all characters that your users enter. For instance, if your database
  is using Latin-1 internally, and your user enters a Russian, Hebrew, or Japanese
  character, the data will be lost forever once it enters the database. If possible,
  use UTF-8 as the internal storage of your database.
